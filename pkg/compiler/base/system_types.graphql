directive @system on OBJECT | INTERFACE | UNION | INPUT_OBJECT | ENUM | FIELD_DEFINITION | SCALAR

# This directive mark type as module root object, thats fields is queries, mutations or functions
# This directive is generated by the compiler as well as module types
directive @module_root(name: String!, type: ModuleObjectType!) on OBJECT

# Original name of the object in the catalog, before prefix was added
# This directive is used generated by the compiler to keep the original name of the object
directive @original_name(name: String!) on OBJECT | INTERFACE | UNION | ENUM | INPUT_OBJECT | SCALAR | FIELD_DEFINITION

extend type __Type {
	hugr_type: String
	module: String
	catalog: String
}

extend type __Field {
	hugr_type: String
	catalog: String
	mcp_exclude: Boolean
}

enum ModuleObjectType @system {
	QUERY
	MUTATION
	FUNCTION
	MUT_FUNCTION
}

input OrderByField @system {
	field: String!
	direction: OrderDirection = ASC
}

enum OrderDirection @system {
	ASC
	DESC
}

type OperationResult @system {
	success: Boolean
	affected_rows: BigInt
	last_id: BigInt
	message: String
}

schema {
	query: Query
}

type Query @system {
	"""
	Performs jq query on result set
	Results will be placed in 'extension' field by field or alias name
	"""
	jq(query: String!, include_origin: Boolean = false): Query @system
}

# generated directives
directive @filter_input(name: String!) on OBJECT | INPUT_OBJECT
directive @filter_list_input(name: String!) on OBJECT | INPUT_OBJECT
directive @data_input(name: String!) on OBJECT | INPUT_OBJECT

directive @query(name: String, type: QueryType) on OBJECT | FIELD_DEFINITION
directive @mutation(name: String, type: MutationType, data_input: String!) on OBJECT | FIELD_DEFINITION
directive @catalog(name: String!, engine: String!) on OBJECT | FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @aggregation(name: String!, is_bucket: Boolean, level: Int) on OBJECT
directive @field_aggregation(name: String!) on OBJECT | FIELD_DEFINITION
directive @aggregation_query(name: String!, is_bucket: Boolean) on FIELD_DEFINITION

directive @extra_field(name: String!, base_field: String!, base_type: ExtraFieldBaseType!) on FIELD_DEFINITION

enum ExtraFieldBaseType @system {
	Timestamp
	Geometry
}


enum QueryType @system {
	SELECT
	SELECT_ONE
}

enum MutationType @system {
	INSERT
	UPDATE
	DELETE
}

enum GeometryType @system {
	POINT
	LINESTRING
	POLYGON
	MULTIPOINT
	MULTILINESTRING
	MULTIPOLYGON
	GEOMETRYCOLLECTION
}

"""
Value distribution data type
"""
type _distribution_by @system {
	# distributed value - numerator * ratio
	value: Float
	# ratio of the value denominator / denominator_total
	ratio: Float
	# non-distributed value - numerator
	numerator: Float
	# distribution base value - denominator
	denominator: Float
	# total value for the denominator, used for ratio calculation
	denominator_total: Float
}

"""
Value distribution aggregation data type
"""
type _distribution_by_aggregation @system {
	# distributed value - numerator * ratio
	value: FloatAggregation
	# ratio of the value denominator / denominator_total
	ratio: FloatAggregation
	# non-distributed value - numerator
	numerator: FloatAggregation
	# distribution base value - denominator
	denominator: FloatAggregation
	# total value for the denominator, used for ratio calculation
	denominator_total: FloatAggregation
}

"""
Value distribution bucket data type
This type is used to store distribution data in buckets.
"""
type _distribution_by_bucket @system{
	# numerator bucket key
	numerator_key: JSON
	# denominator bucket key
	denominator_key: JSON
	# distributed value - numerator * ratio
	value: Float
	# ratio of the value denominator / denominator_total
	ratio: Float
	# non-distributed value - numerator
	numerator: Float
	# distribution base value - denominator
	denominator: Float
	# total value for the denominator, used for ratio calculation
	denominator_total: Float
}

"""
Value distribution bucket aggregation data type
"""
type _distribution_by_bucket_aggregation @system {
	# bucket key
	key: JSONAggregation
	# distributed value - numerator * ratio
	value: FloatAggregation
	# ratio of the value denominator / denominator_total
	ratio: FloatAggregation
	# non-distributed value - numerator
	numerator: FloatAggregation
	# distribution base value - denominator
	denominator: FloatAggregation
	# total value for the denominator, used for ratio calculation
	denominator_total: FloatAggregation
}