# Define module for data objects and functions
directive @module(name: String!) on OBJECT | FIELD_DEFINITION

# define function info (apply to the extended Function or MutationFunction type)
directive @function(
	name: String!
	sql: String
	skip_null_arg: Boolean
	is_table: Boolean
	json_cast: Boolean
) on FIELD_DEFINITION


# Mark object as table in the datasource
directive @table(
	name: String!
	is_m2m: Boolean = false
	"""
	Apply soft delete to table
	"""
	soft_delete: Boolean = false
	"""
	Soft delete condition to check if record is deleted
	"""
	soft_delete_cond: String
	"""
	Soft delete update condition to update record as deleted
	"""
	soft_delete_set: String
) on OBJECT

# Mark object as view in the datasource
directive @view(name: String!, sql: String) on OBJECT

# The arguments for the view directive defines input name to request data
directive @args(name: String!, required: Boolean = false) on OBJECT

# Add list of dependencies (data sources) to the views or objects it is used in.
# This directive is repeatable, allowing multiple dependencies to be specified for a single object.
directive @dependency(
	name: String!
) repeatable on OBJECT

# The argument is named
directive @named(name: String) on INPUT_FIELD_DEFINITION 

# Add unique constraint to the object
directive @unique(fields: [String]!, query_suffix: String, skip_query: Boolean) repeatable on OBJECT

# Fields directives

# Include field to primary key
directive @pk on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# sql for calculate field value, expression should be in sql format, all fields should placed in the []
directive @sql(exp: String!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION  # calculate field value from sql expression, can be only in data object (table or view)

directive @unique_rule(rule: UniqueRuleType) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION 

# default value for field, if field is not nullable, define sequences for the field
directive @default(
	"""
	Default value for the field
	"""
	value: any
	"""
	Sequence for the autogenerated identifier
	"""
	sequence: String
	"""
	Insert sql expressions for the field that returns inserted value. Can use values from input argument - [$<input field name>].
	"""
	insert_exp: String
	"""
	Update sql expressions for the field that returns updated value. Can use values from input argument - [$<input field name>] and current row values with prefix objects.<field_name>.
	"""
	update_exp: String
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

# field name in the database
directive @field_source(field: String!) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# define additional info for the geometry field
directive @geometry_info(
	type: GeometryType
	srid: Int
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION

# exclude operators for the filter
directive @exclude_filter(
	operations: [FilterOperator!]
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# define that the by filter is required
directive @filter_required on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# exclude field or table to use in MCP client
directive @exclude_mcp on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# define the embeddings model and vector field to use semantic search in the data object.
directive @embeddings(
	"The name of the data source type `embedding`"
	model: String!
	"The name of the field that contains embeddings vector"
	vector: String!
	"The distance metric to use for the vector search"
	distance: VectorDistanceType!
) on OBJECT

"""
Mark data object (table, view, cube) as PostgreSQL TimescaleDB Hypertable
"""
directive @hypertable on OBJECT
"""
Mark timestamp field as a postgres timescale key in hypertable or continues aggregation view
"""
directive @timescale_key on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

"""
Mark data object as cube, data will be pre aggregated before selected base on selection set
"""
directive @cube on OBJECT

"""
Mark field as measurement in cube.
If field is marked as measurement and object is marked as cube, aggregation func parameter will be added to the field.
Aggregation func should be return the same type as field type.
"""
directive @measurement on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# define FK on the data object (view or table)
directive @references(
	name: String
	references_name: String!
	source_fields: [String!]!
	references_fields: [String!]!
	description: String
	query: String
	references_query: String
	references_description: String
	is_m2m: Boolean
	m2m_name: String
) repeatable on OBJECT

# define FK on the data object field (view or table)
directive @field_references(
	name: String
	references_name: String!
	field: String
	query: String # query field name in object
	description: String
	references_query: String # query field name in reference object
	references_description: String
) repeatable on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# define subquery for FK or function call

# define field as join result from the other data object
directive @join(
	references_name: String!
	source_fields: [String!]
	references_fields: [String!]
	sql: String # sql for join to indicate tables use source and dest names in field path, all fields path should in [source.field] or [dest.field] format
) on FIELD_DEFINITION | FIELD | INPUT_FIELD_DEFINITION

# automatically generated query to references data object if references is defined
directive @references_query(
	references_name: String!
	name: String
	is_m2m: Boolean
	m2m_name: String
) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# function call
directive @function_call(
	references_name: String!
	args: JSON # argument map from field to function argument
	module: String # module name for the function
) on FIELD_DEFINITION

directive @table_function_call_join(
	references_name: String!
	args: JSON # argument map from field to function argument
	source_fields: [String!]
	references_fields: [String!]
	sql: String # sql for join to indicate tables use source and dest names in field path, all fields path should in [source.field] or [dest.field] format
	module: String
) on FIELD_DEFINITION



enum UniqueRuleType @system {
    EQUALS
    INTERSECTS # for geometry and range types
}

directive @cache(
	ttl: Int
	"""
	Cache key for the query
	"""
	key: String
	"""
	Cache key for the query
	"""
	tags: [String!]
) on FIELD | OBJECT | FIELD_DEFINITION
